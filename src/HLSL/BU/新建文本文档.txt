float4 main(float4 vpos : SV_Position, float2 texcoord : TEXCOORD0) : SV_Target 
{
    float2 pos = texcoord / PixelSize;

	float2 screenSize = float2(BUFFER_WIDTH,BUFFER_HEIGHT);
	float2 standredSize = float2(1920,1080);
	float2 diffSize = screenSize*rcp(standredSize);

	float baseFov = 90;
	//float fovDiff = GameFov/(baseFov * 1.1);
	/// 1 + (1.1 * ((baseFov-GameFov) * 0.005 ));
	float fovDiff = 1;

	float4 color = tBACKBUFFER.Sample(gSamLinear,texcoord);
	float2 corrected_texturecoords = aspect_ratio_correction(texcoord);
	//aspect_ratio_correction(texcoord);

	float2 texcoordCorrected = corrected_texturecoords;
	float3 ViewDir = normalize(mul(transpose(CameraRotation),eyeDirection.yxz));
	// 0.25 * normalize(mul(transpose(CameraRotation),eyeDirection.xyz));
	ViewDir.y *= -1;

	float3 abseyeDirectionLerp = mul(transpose(CameraRotation),eyeDirectionLerp.yxz);
	
	if(abseyeDirectionLerp.x < 0 && abseyeDirectionLerp.x >= -0.0025)
		abseyeDirectionLerp.x = -0.0025;
	else if(abseyeDirectionLerp.x >= 0 && abseyeDirectionLerp.x <= 0.0025)
		abseyeDirectionLerp.x = 0.0025;

	float3 abseyeTranslationLerp = mul(CameraRotation,eyeTranslationLerp);

	if(abseyeTranslationLerp.x < 0 && abseyeTranslationLerp.x >= -0.0025)
		abseyeTranslationLerp.x = -0.0025;
	else if(abseyeTranslationLerp.x >= 0 && abseyeTranslationLerp.x <= 0.0025)
		abseyeTranslationLerp.x = 0.0025;
	
	float2 eye_velocity = clampMagnitude(((abseyeDirectionLerp * 0.4) ).xy , 5);
	eye_velocity.y *=-1;

	float2 scope_center = float2(0.5f, 0.5f);
	float2 parallax_offset = float2(scope_center.x,scope_center.y) + eye_velocity;
	float distToParallax = distance(corrected_texturecoords, parallax_offset);
	
	float distToCenter = distance(corrected_texturecoords, scope_center);

	float4 colorBackup = color;
	float2 areaCenter = ScopeEffect_Size * 0.5 * rcp(fovDiff);
	float2 ScreenCenter = screenSize * 0.5 - areaCenter;

	float distanceWeap = sqrt(
	  pow(CurrWeaponPos.x - CurrRootPos.x, 2) 
	+ pow(CurrWeaponPos.y - CurrRootPos.y, 2) 
	+ pow(CurrWeaponPos.z - CurrRootPos.z, 2)
	//pow(CurrWeaponPos.z - CurrRootPos.z, 2)
	);

	float zMove = abs(sqrt((BaseWeaponPos)) - distanceWeap) + 1;
	float zMoveDiff = (1- EnableZMove * MovePercentage)+ EnableZMove * MovePercentage * rcp(zMove);
	if(step (zMoveDiff,0.5) == 1) zMoveDiff = 0.5;
	if(step(zMoveDiff,2) == 0) zMoveDiff = 1.5;

	float dx = pos.x - areaCenter.x - ScreenCenter.x;
	float dy = pos.y - areaCenter.y - ScreenCenter.y;
	float r = (ScopeEffect_Size.x)  * 0.5 * diffSize.x * rcp(fovDiff) * rcp(zMoveDiff);

	float2 destTopLeft = screenSize * 0.5 - ScopeEffect_Size * 0.5;
    float2 destBottomRight = screenSize * 0.5 + ScopeEffect_Size * 0.5;
	destTopLeft *= diffSize.x * rcp( fovDiff) * rcp(zMoveDiff);
    destBottomRight *=diffSize.y * rcp( fovDiff) * rcp( zMoveDiff);

	bool isRender =  ((dx * dx + dy * dy < r * r) && isCircle) || ((pos.x >= destTopLeft.x && pos.y >= destTopLeft.y && pos.x <= destBottomRight.x && pos.y <= destBottomRight.y) && (!isCircle));
	// bool isRender = dx * dx + dy * dy < r * r;
	// 	//isCircle ?  : pos.x >= destTopLeft.x && pos.y >= destTopLeft.y && pos.x <= destBottomRight.x && pos.y <= destBottomRight.y;

	float2 ReticlePos;
	float2 ReticleCoord;

	ReticlePos.x = (pos.x - ScreenCenter.x - areaCenter.x) * 16 *rcp(ReticleSize) * (AspectRatio) + ScreenCenter.x + areaCenter.x;
	ReticlePos.y = (pos.y - ScreenCenter.y - areaCenter.y) * 16 *rcp(ReticleSize) + ScreenCenter.y + areaCenter.y;
	ReticleCoord = ReticlePos * PixelSize;

	float4 ReticleColor = ReticleTex.Sample(gSamLinear,ReticleCoord);

	float2 destPos = (
		pos.xy - ScreenCenter - areaCenter 
		- float2(0.5F,0) * (ViewDir.xy/PixelSize)
	) *rcp(ScopeEffect_Zoom)
	+ ScreenCenter 
	+ ScopeEffect_OriPositionOffset
	+ areaCenter
	+ float2(0.5F,0) * (ViewDir.xy/PixelSize)
	;
	
    float2 destCoord = destPos * diffSize * PixelSize;

	float4 colorDest= tBACKBUFFER.Sample(gSamLinear,destCoord);

	float power = 0.008 * rcp(diffSize.y);
	color.xyz = lerp(colorBackup.xyz, colorDest.xyz, 1);

	color.r = tBACKBUFFER.Sample(gSamLinear,mad(float2(-power,0),distToCenter,destCoord)).r;
	color.b = tBACKBUFFER.Sample(gSamLinear,mad(float2(power,0),distToCenter,destCoord)).b;
	color.g = tBACKBUFFER.Sample(gSamLinear,destCoord).g;
	

	float4 nColor =  EnableNV * NVGEffect(color,corrected_texturecoords);
	color = nColor * nColor.a + color * (1 - nColor.a);
	color.rgb *=  (step(distToCenter, 2) * getparallax(distToParallax,diffSize,fovDiff));
	color = ReticleColor * ReticleColor.a + color * (1-ReticleColor.a);
	
	float4 colorFinal = color;
	colorFinal.a *= EnableMerge;

	return colorFinal;
}

